<!DOCTYPE html><html><head><meta charset="utf-8"><title>Creating your own OpenID Connect server with ASOS: implementing the resource owner password credentials grant | Kévin Chalet&#39;s blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="In this post, learn how you can implement the resource owner password credentials grant using ASOS."><meta property="og:type" content="article"><meta property="og:title" content="Creating your own OpenID Connect server with ASOS: implementing the resource owner password credentials grant"><meta property="og:url" content="http://kevinchalet.com/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-resource-owner-password-credentials-grant/index.html"><meta property="og:site_name" content="Kévin Chalet's blog"><meta property="og:description" content="In this post, learn how you can implement the resource owner password credentials grant using ASOS."><meta property="og:updated_time" content="2016-10-09T10:46:20.820Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Creating your own OpenID Connect server with ASOS: implementing the resource owner password credentials grant"><meta name="twitter:description" content="In this post, learn how you can implement the resource owner password credentials grant using ASOS."><meta name="twitter:creator" content="@PinpointTownes"><link rel="icon" href="/css/images/favicon.ico"><link rel="stylesheet" href="/css/style.css" type="text/css"><link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css"><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-79360312-1","auto"),ga("send","pageview");</script></head></html><body><div id="container"><header id="header"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><span class="site-title">Kévin Chalet&#39;s blog</span></a><nav id="main-nav"><a class="main-nav-link" href="/.">Home</a> <a class="main-nav-link" href="/archives">Archives</a></nav><nav id="sub-nav"><div class="profile" id="profile-nav"><a id="profile-anchor" href="javascript:;"><img class="avatar" src="https://avatars3.githubusercontent.com/u/6998306?v=3&amp;s=460"><i class="fa fa-caret-down"></i></a></div></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"></button><input type="hidden" name="sitesearch" value="http://kevinchalet.com"></form></div></div></div></header><div class="outer"><aside id="profile"><div class="inner profile-inner"><div class="base-info profile-block"><img id="avatar" src="https://avatars3.githubusercontent.com/u/6998306?v=3&amp;s=460"><h2 id="name">Kévin Chalet</h2><h3 id="title">.NET-holic and OpenID-addict MVP in the wild.</h3><span id="location"><i class="fa fa-map-marker"></i>France</span> <a id="follow" href="https://twitter.com/intent/user?screen_name=PinpointTownes"><i class="fa fa-twitter fa-lg"></i> Follow me on Twitter</a></div><div class="article-info profile-block"><div class="article-info-block">10 <span>posts</span></div><div class="article-info-block">9 <span>tags</span></div></div><div class="contact-info profile-block"><table class="contact-list"><tr><td><a href="https://github.com/PinpointTownes" target="_blank" title="GitHub"><i class="fa fa-github"></i></a></td><td><a href="https://twitter.com/PinpointTownes" target="_blank" title="Twitter"><i class="fa fa-twitter"></i></a></td><td><a href="http://stackoverflow.com/users/542757/pinpoint" target="_blank" title="StackOverflow"><i class="fa fa-stack-overflow"></i></a></td><td><a href="https://mvp.microsoft.com/fr-fr/PublicProfile/5001682" target="_blank" title="Microsoft MVP"><i class="fa fa-windows"></i></a></td><td><a href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id="main"><article id="post-creating-your-own-openid-connect-server-with-asos-implementing-the-resource-owner-password-credentials-grant" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">Creating your own OpenID Connect server with ASOS: implementing the resource owner password credentials grant</h1><div class="article-meta"><div class="article-date"><i class="fa fa-calendar"></i> <a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-resource-owner-password-credentials-grant/"><time datetime="2016-07-13T16:00:00.000Z" itemprop="datePublished">2016-07-13</time></a></div><div class="article-category"><i class="fa fa-folder"></i> <a class="article-category-link" href="/categories/development/">Development</a></div></div></header><div class="article-entry" itemprop="articleBody"><div class="note tip"><p>This post is the fifth part of a series of blog posts entitled <strong>Creating your own OpenID Connect server with ASOS</strong>:</p><ol><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-introduction/" title="Introduction">Introduction</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-choosing-the-right-flows/" title="Choosing the right flow(s)">Choosing the right flow(s)</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-registering-the-middleware-in-the-asp-net-core-pipeline/" title="Registering the middleware in the ASP.NET Core pipeline">Registering the middleware in the ASP.NET Core pipeline</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-creating-your-own-authorization-provider/" title="Creating your own authorization provider">Creating your own authorization provider</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-resource-owner-password-credentials-grant/" title="Implementing the resource owner password credentials grant">Implementing the resource owner password credentials grant</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-authorization-code-and-implicit-flows/" title="Implementing the authorization code and implicit flows">Implementing the authorization code and implicit flows</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-adding-custom-claims-and-granting-scopes/" title="Adding custom claims and granting scopes">Adding custom claims and granting scopes</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-testing-your-authorization-server-with-postman/" title="Testing your authorization server with Postman">Testing your authorization server with Postman</a></li><li><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-conclusion/" title="Conclusion">Conclusion</a></li></ol></div><p>Implementing the resource owner password credentials grant (abbreviated <code>ROPC</code> for brevity) is quite easy with ASOS as the only thing you have to do is to provide your own implementation of <code>ValidateTokenRequest</code> and <code>HandleTokenRequest</code>.</p><p>But to properly implement these events, you first need to determine what&#39;s the best client authentication policy for your application.</p><hr><h2 id="Implementing_ValidateTokenRequest_to_validate_the_grant_type_and_the_client_application_credentials"><a href="#Implementing_ValidateTokenRequest_to_validate_the_grant_type_and_the_client_application_credentials" class="headerlink" title="Implementing ValidateTokenRequest to validate the grant type and the client application credentials"></a>Implementing <code>ValidateTokenRequest</code> to validate the grant type and the client application credentials</h2><p>When implementing flows using backchannel communication (i.e resource owner password credentials grant, client credentials grant, authorization code flow or refresh token grant), the <code>ValidateTokenRequest</code> event must be overridden to validate the token request.</p><p>So, what are you supposed to validate in this event? Mainly two things:</p><ul><li><strong>The grant type</strong>: in most cases, you&#39;ll likely want to restrict the grants a client application is allowed to use (e.g resource owner password credentials only): <code>ValidateTokenRequest</code> is the best place for that.</li></ul><div class="note info"><p>It should be noted that ASOS doesn&#39;t validate the <code>grant_type</code> value, <a href="https://tools.ietf.org/html/rfc6749#section-4.5" target="_blank" rel="external">that can even contain a custom value for extension grants</a>: if you only want to support standard grants, it&#39;s up to you to reject the token request by calling <code>context.Reject()</code>.</p><p><code>IsAuthorizationCodeGrantType()</code>, <code>IsRefreshTokenGrantType()</code>, <code>IsPasswordGrantType()</code> and <code>IsClientCredentialsGrantType()</code> can be used for this exact purpose.</p></div><ul><li><strong>The client credentials</strong> (<code>client_id</code>/<code>client_secret</code>): the OAuth2 specification explicitly states <strong>that confidential applications</strong> (i.e applications that are able to keep their credentials secret, like server-side apps) <strong>must authenticate when using the token endpoint</strong>. This security measure is extremely important as it&#39;s the only way to prevent malicious applications from retrieving an access token on behalf of a legitimate confidential application.</li></ul><div class="note info"><p>Contrary to popular belief, client authentication is never mandatory when using the token endpoint (except for the client credentials grant), which means that <strong>public applications like JS or mobile apps are allowed to use the resource owner password grant without having to send their credentials</strong>.</p><p>In practice, it&#39;s up to you to decide whether your token endpoint should accept unauthenticated requests or not, depending on the type of client you&#39;ll use.</p></div><a id="more"></a><p>No big surprise here: while a few rules apply to most implementations (e.g brute force countermeasures), <strong>the exact implementation of this event will mainly depend on your specific requirements</strong>:</p><ul><li><p>Do you need to support multiple grant types, or just the resource owner password credentials grant?</p></li><li><p>Do you need to support public clients? If you plan to use ROPC with JS or mobile applications, you won&#39;t be able to make client authentication mandatory, since these applications cannot safely store their credentials. Conversely, if you only target public apps, rolling your own client authentication policy is likely to be pointless.</p></li></ul><div class="note tip"><p>When supporting both public and confidential clients, the recommended approach is to skip client authentication when <code>client_id</code> is missing and validate it when present, <strong>to make sure counterfeit applications cannot impersonate confidential applications</strong>.</p></div><ul><li>Do you have multiple clients? If you have more than one client application, you&#39;ll probably want to store the application details in a database instead of hardcoding them in the provider class.</li></ul><hr><h3 id="Implementing_a_policy_skipping_client_authentication__28for_JS/mobile_apps-only_scenarios_29"><a href="#Implementing_a_policy_skipping_client_authentication__28for_JS/mobile_apps-only_scenarios_29" class="headerlink" title="Implementing a policy skipping client authentication (for JS/mobile apps-only scenarios)"></a>Implementing a policy skipping client authentication (for JS/mobile apps-only scenarios)</h3><p>Using the resource owner password credentials grant with SPA apps is a very popular scenario. Since these apps can&#39;t store their credentials in a safe place, client authentication cannot be enforced.</p><p>Here&#39;s how you could implement <code>ValidateTokenRequest</code> to avoid making client authentication mandatory:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">ValidateTokenRequest</span>(<span class="params">ValidateTokenRequestContext context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Reject the token requests that don't use grant_type=password or grant_type=refresh_token.</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.IsPasswordGrantType() &amp;&amp; !context.Request.IsRefreshTokenGrantType()) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.UnsupportedGrantType,</span><br><span class="line">            description: <span class="string">"Only the resource owner password credentials and refresh token "</span> +</span><br><span class="line">                         <span class="string">"grants are accepted by this authorization server"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since there's only one application and since it's a public client</span></span><br><span class="line">    <span class="comment">// (i.e a client that cannot keep its credentials private), call Skip()</span></span><br><span class="line">    <span class="comment">// to inform the server the request should be accepted without </span></span><br><span class="line">    <span class="comment">// enforcing client authentication.</span></span><br><span class="line">    context.Skip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>Though additional checks can be added (e.g <code>Origin</code> header validation), <strong>you have no way</strong> to ensure that the caller sending the token request is really a trusted application when skipping client authentication: keep in mind that <strong>access tokens may be issued to unauthorized parties impersonating legitimate applications</strong>.</p><p>When client authentication is not enforced, the resource owner password credentials grant offers the same security level as the implicit flow and shares a similar threat model.</p></div><hr><h3 id="Implementing_a_policy_requiring_client_authentication__28for_server-side_apps-only_scenarios_29"><a href="#Implementing_a_policy_requiring_client_authentication__28for_server-side_apps-only_scenarios_29" class="headerlink" title="Implementing a policy requiring client authentication (for server-side apps-only scenarios)"></a>Implementing a policy requiring client authentication (for server-side apps-only scenarios)</h3><p>This scenario is the exact opposite of the previous one: when targeting confidential applications, you MUST enforce client authentication to prevent client impersonation by unauthorized parties and the token request must be rejected if the client credentials are missing or invalid.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">ValidateTokenRequest</span>(<span class="params">ValidateTokenRequestContext context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Reject the token request that don't use grant_type=password or grant_type=refresh_token.</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.IsPasswordGrantType() &amp;&amp; !context.Request.IsRefreshTokenGrantType()) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.UnsupportedGrantType,</span><br><span class="line">            description: <span class="string">"Only resource owner password credentials and refresh token "</span> +</span><br><span class="line">                         <span class="string">"are accepted by this authorization server"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject the token request if client_id or client_secret is missing.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(context.ClientId) || <span class="keyword">string</span>.IsNullOrEmpty(context.ClientSecret)) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.InvalidRequest,</span><br><span class="line">            description: <span class="string">"Missing credentials: ensure that your credentials were correctly "</span> +</span><br><span class="line">                         <span class="string">"flowed in the request body or in the authorization header"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: to mitigate brute force attacks, you SHOULD strongly consider applying</span></span><br><span class="line">    <span class="comment">// a key derivation function like PBKDF2 to slow down the secret validation process.</span></span><br><span class="line">    <span class="comment">// You SHOULD also consider using a time-constant comparer to prevent timing attacks.</span></span><br><span class="line">    <span class="comment">// For that, you can use the CryptoHelper library developed by @henkmollema:</span></span><br><span class="line">    <span class="comment">// https://github.com/henkmollema/CryptoHelper. If you don't need .NET Core support,</span></span><br><span class="line">    <span class="comment">// SecurityDriven.NET/inferno is a rock-solid alternative: http://securitydriven.net/inferno/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.Equals(context.ClientId, <span class="string">"client_id"</span>, StringComparison.Ordinal) &amp;&amp;</span><br><span class="line">        <span class="keyword">string</span>.Equals(context.ClientSecret, <span class="string">"client_secret"</span>, StringComparison.Ordinal)) &#123;</span><br><span class="line">        context.Validate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: if Validate() is not explicitly called,</span></span><br><span class="line">    <span class="comment">// the request is automatically rejected.</span></span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Implementing_an_hybrid_policy_supporting_both_public_and_confidential_applications"><a href="#Implementing_an_hybrid_policy_supporting_both_public_and_confidential_applications" class="headerlink" title="Implementing an hybrid policy supporting both public and confidential applications"></a>Implementing an hybrid policy supporting both public and confidential applications</h3><p>In a few cases, you&#39;ll want to support both public clients (e.g mobile apps) and confidential applications (e.g MVC clients). For that, you&#39;ll need to implement an hybrid policy, supporting both types of clients:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ValidateTokenRequest</span>(<span class="params">ValidateTokenRequestContext context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> database = context.HttpContext.RequestServices.GetRequiredService&lt;ApplicationContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject the token request that don't use grant_type=password or grant_type=refresh_token.</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.IsPasswordGrantType() &amp;&amp; !context.Request.IsRefreshTokenGrantType()) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.UnsupportedGrantType,</span><br><span class="line">            description: <span class="string">"Only resource owner password credentials and refresh token "</span> +</span><br><span class="line">                         <span class="string">"are accepted by this authorization server"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip client authentication if the client identifier is missing.</span></span><br><span class="line">    <span class="comment">// Note: ASOS will automatically ensure that the calling application</span></span><br><span class="line">    <span class="comment">// cannot use an authorization code or a refresh token if it's not</span></span><br><span class="line">    <span class="comment">// the intended audience, even if client authentication was skipped.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(context.ClientId)) &#123;</span><br><span class="line">        context.Skip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve the application details corresponding to the requested client_id.</span></span><br><span class="line">    <span class="keyword">var</span> application = <span class="keyword">await</span> (<span class="keyword">from</span> entity <span class="keyword">in</span> database.Applications</span><br><span class="line">                             <span class="keyword">where</span> entity.ApplicationID == context.ClientId</span><br><span class="line">                             <span class="keyword">select</span> entity).SingleOrDefaultAsync(context.HttpContext.RequestAborted);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.InvalidClient,</span><br><span class="line">            description: <span class="string">"Application not found in the database: ensure that your client_id is correct."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.Type == ApplicationType.Public) &#123;</span><br><span class="line">        <span class="comment">// Reject tokens requests containing a client_secret</span></span><br><span class="line">        <span class="comment">// if the client application is not confidential.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(context.ClientSecret)) &#123;</span><br><span class="line">            context.Reject(</span><br><span class="line">                error: OpenIdConnectConstants.Errors.InvalidRequest,</span><br><span class="line">                description: <span class="string">"Public clients are not allowed to send a client_secret."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If client authentication cannot be enforced, call context.Skip() to inform</span></span><br><span class="line">        <span class="comment">// the OpenID Connect server middleware that the caller cannot be fully trusted.</span></span><br><span class="line">        context.Skip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confidential applications MUST authenticate</span></span><br><span class="line">    <span class="comment">// to protect them from impersonation attacks.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(context.ClientSecret)) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.InvalidClient,</span><br><span class="line">            description: <span class="string">"Missing credentials: ensure that you specified a client_secret."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: to mitigate brute force attacks, you SHOULD strongly consider applying</span></span><br><span class="line">    <span class="comment">// a key derivation function like PBKDF2 to slow down the secret validation process.</span></span><br><span class="line">    <span class="comment">// You SHOULD also consider using a time-constant comparer to prevent timing attacks.</span></span><br><span class="line">    <span class="comment">// For that, you can use the CryptoHelper library developed by @henkmollema:</span></span><br><span class="line">    <span class="comment">// https://github.com/henkmollema/CryptoHelper. If you don't need .NET Core support,</span></span><br><span class="line">    <span class="comment">// SecurityDriven.NET/inferno is a rock-solid alternative: http://securitydriven.net/inferno/</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.Equals(context.ClientSecret, application.Secret, StringComparison.Ordinal)) &#123;</span><br><span class="line">        context.Reject(</span><br><span class="line">            error: OpenIdConnectConstants.Errors.InvalidClient,</span><br><span class="line">            description: <span class="string">"Invalid credentials: ensure that you specified a correct client_secret."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.Validate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Implementing_HandleTokenRequest_to_issue_an_authentication_ticket_containing_the_user_claims"><a href="#Implementing_HandleTokenRequest_to_issue_an_authentication_ticket_containing_the_user_claims" class="headerlink" title="Implementing HandleTokenRequest to issue an authentication ticket containing the user claims"></a>Implementing <code>HandleTokenRequest</code> to issue an authentication ticket containing the user claims</h2><p><code>HandleTokenRequest</code> is <strong>the event responsible of processing the token request and preparing the authentication ticket</strong> used to serialize the access token.</p><div class="note info"><p>It&#39;s important to note that <code>HandleTokenRequest</code> is invoked for every token request. User implementations should only process token requests that use a supported <code>grant_type</code> (e.g <code>password</code>) and let ASOS automatically handle or reject the other grants (e.g <code>authorization_code</code> or <code>refresh_token</code>).</p></div><p>Like <code>ValidateTokenRequest</code>, the exact implementation of <code>HandleTokenRequest</code> will mainly depend on your application, and specially on the membership stack you&#39;re using. That said, a few generic rules apply to all implementations:</p><ul><li><strong>Brute force countermeasures MUST be implemented</strong>, <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2" target="_blank" rel="external">as required by the OAuth2 specification</a>. This is usally done by using key derivation (ideally with a large number of iterations, to slow down the authentication process) and by implementing account lockout.</li><li><strong>The token request MUST be rejected if the user account is configured to require two-factor authentication</strong> as the resource owner password credentials grant cannot be used in this case (at least, not in a standard way).</li><li><strong>Implementations SHOULD avoid revealing whether the username is valid or not</strong>, for <a href="https://www.troyhunt.com/everything-you-ever-wanted-to-know/" target="_blank" rel="external">privacy reasons</a>.</li></ul><p>Here&#39;s an example of how you can leverage <a href="https://github.com/aspnet/Identity" target="_blank" rel="external">ASP.NET Core Identity</a> (previously known as ASP.NET Identity 3) to implement <code>HandleTokenRequest</code>:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">HandleTokenRequest</span>(<span class="params">HandleTokenRequestContext context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Resolve ASP.NET Core Identity's user manager from the DI container.</span></span><br><span class="line">    <span class="keyword">var</span> manager = context.HttpContext.RequestServices.GetRequiredService&lt;UserManager&lt;ApplicationUser&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only handle grant_type=password requests and let ASOS</span></span><br><span class="line">    <span class="comment">// process grant_type=refresh_token requests automatically.</span></span><br><span class="line">    <span class="keyword">if</span> (context.Request.IsPasswordGrantType()) &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> manager.FindByNameAsync(context.Request.Username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context.Reject(</span><br><span class="line">                error: OpenIdConnectConstants.Errors.InvalidGrant,</span><br><span class="line">                description: <span class="string">"Invalid credentials."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the user is allowed to sign in.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">await</span> manager.CanSignInAsync(user)) &#123;</span><br><span class="line">            context.Reject(</span><br><span class="line">                error: OpenIdConnectConstants.Errors.InvalidGrant,</span><br><span class="line">                description: <span class="string">"The specified user is not allowed to sign in."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reject the token request if two-factor authentication has been enabled by the user.</span></span><br><span class="line">        <span class="keyword">if</span> (manager.SupportsUserTwoFactor &amp;&amp; <span class="keyword">await</span> manager.GetTwoFactorEnabledAsync(user)) &#123;</span><br><span class="line">            context.Reject(</span><br><span class="line">                error: OpenIdConnectConstants.Errors.InvalidGrant,</span><br><span class="line">                description: <span class="string">"Two-factor authentication is required for this account."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the user is not already locked out.</span></span><br><span class="line">        <span class="keyword">if</span> (manager.SupportsUserLockout &amp;&amp; <span class="keyword">await</span> manager.IsLockedOutAsync(user)) &#123;</span><br><span class="line">            context.Reject(</span><br><span class="line">                error: OpenIdConnectConstants.Errors.InvalidGrant,</span><br><span class="line">                description: <span class="string">"Invalid credentials."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the password is valid.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">await</span> manager.CheckPasswordAsync(user, context.Request.Password)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (manager.SupportsUserLockout) &#123;</span><br><span class="line">                <span class="keyword">await</span> manager.AccessFailedAsync(user);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            context.Reject(</span><br><span class="line">                error: OpenIdConnectConstants.Errors.InvalidGrant,</span><br><span class="line">                description: <span class="string">"Invalid credentials."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (manager.SupportsUserLockout) &#123; </span><br><span class="line">            <span class="keyword">await</span> manager.ResetAccessFailedCountAsync(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> identity = <span class="keyword">new</span> ClaimsIdentity(context.Options.AuthenticationScheme);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: the name identifier is always included in both identity and</span></span><br><span class="line">        <span class="comment">// access tokens, even if an explicit destination is not specified.</span></span><br><span class="line">        identity.AddClaim(ClaimTypes.NameIdentifier, <span class="keyword">await</span> manager.GetUserId(user));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When adding custom claims, you MUST specify one or more destinations.</span></span><br><span class="line">        <span class="comment">// Read "part 7" for more information about custom claims and scopes.</span></span><br><span class="line">        identity.AddClaim(<span class="string">"username"</span>, <span class="keyword">await</span> manager.GetUserNameAsync(user),</span><br><span class="line">            OpenIdConnectConstants.Destinations.AccessToken,</span><br><span class="line">            OpenIdConnectConstants.Destinations.IdentityToken);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new authentication ticket holding the user identity.</span></span><br><span class="line">        <span class="keyword">var</span> ticket = <span class="keyword">new</span> AuthenticationTicket(</span><br><span class="line">            <span class="keyword">new</span> ClaimsPrincipal(identity),</span><br><span class="line">            <span class="keyword">new</span> AuthenticationProperties(),</span><br><span class="line">            context.Options.AuthenticationScheme);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the list of scopes granted to the client application.</span></span><br><span class="line">        ticket.SetScopes(</span><br><span class="line">            <span class="comment">/* openid: */</span> OpenIdConnectConstants.Scopes.OpenId,</span><br><span class="line">            <span class="comment">/* email: */</span> OpenIdConnectConstants.Scopes.Email,</span><br><span class="line">            <span class="comment">/* profile: */</span> OpenIdConnectConstants.Scopes.Profile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the resource servers the access token should be issued for.</span></span><br><span class="line">        ticket.SetResources(<span class="string">"resource_server"</span>);</span><br><span class="line"></span><br><span class="line">        context.Validate(ticket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Next part: <a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-authorization-code-and-implicit-flows/" title="Implementing the authorization code and implicit flows">Implementing the authorization code and implicit flows</a>.</p></div><footer class="article-footer"><a data-url="http://kevinchalet.com/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-resource-owner-password-credentials-grant/" data-id="cis3b6p1k001dz8i2v2udl9ql" class="article-share-link">Share</a> <a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-resource-owner-password-credentials-grant/#disqus_thread" class="article-comment-link">Comments</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/asp-net-core/">asp.net core</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aspnet-contrib/">aspnet-contrib</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/authentication/">authentication</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jwt/">jwt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oauth/">oauth</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openid-connect/">openid connect</a></li></ul></footer></div><nav id="article-nav"><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-authorization-code-and-implicit-flows/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Creating your own OpenID Connect server with ASOS: implementing the authorization code and implicit flows</div></a> <a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-creating-your-own-authorization-provider/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Creating your own OpenID Connect server with ASOS: creating your own authorization provider</div></a></nav></article><section id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">recents</h3><div class="widget"><ul id="recent-post" class="no-thumbnail"><li><div class="item-inner"><p class="item-title"><a href="/2016/08/22/using-a-local-oauth2-openid-connect-server-with-webauthenticationbroker/" class="title">Using a local OAuth2/OpenID Connect server with WebAuthenticationBroker</a></p><p class="item-date"><time datetime="2016-08-22T14:30:00.000Z" itemprop="datePublished">2016-08-22</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-conclusion/" class="title">Creating your own OpenID Connect server with ASOS: conclusion</a></p><p class="item-date"><time datetime="2016-07-13T17:00:00.000Z" itemprop="datePublished">2016-07-13</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-testing-your-authorization-server-with-postman/" class="title">Creating your own OpenID Connect server with ASOS: testing your authorization server with Postman</a></p><p class="item-date"><time datetime="2016-07-13T16:45:00.000Z" itemprop="datePublished">2016-07-13</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-adding-custom-claims-and-granting-scopes/" class="title">Creating your own OpenID Connect server with ASOS: adding custom claims and granting scopes</a></p><p class="item-date"><time datetime="2016-07-13T16:30:00.000Z" itemprop="datePublished">2016-07-13</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/2016/07/13/creating-your-own-openid-connect-server-with-asos-implementing-the-authorization-code-and-implicit-flows/" class="title">Creating your own OpenID Connect server with ASOS: implementing the authorization code and implicit flows</a></p><p class="item-date"><time datetime="2016-07-13T16:15:00.000Z" itemprop="datePublished">2016-07-13</time></p></div></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/development/">Development</a><span class="category-list-count">10</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">tags</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/asp-net-core/">asp.net core</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aspnet-contrib/">aspnet-contrib</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/authentication/">authentication</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jwt/">jwt</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oauth/">oauth</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openid-connect/">openid connect</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uwp/">uwp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-authentication-broker/">web authentication broker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows-10/">windows 10</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">9</span></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2016 Kévin Chalet<br>Proudly powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with <a href="http://github.com/ppoffice" target="_blank">Ruipeng Zhang</a>'s <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus theme</a> and <a href="https://www.flickr.com/photos/madison_slater/" target="_blank">Madison Slater</a>'s <a href="https://www.flickr.com/photos/madison_slater/11299339856/" target="_blank">photos</a>.</div></div></footer><script>var disqus_shortname="kevinchalet";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}();</script><script src="/js/jquery.js" type="text/javascript"></script><script src="/js/script.js" type="text/javascript"></script></div></body>